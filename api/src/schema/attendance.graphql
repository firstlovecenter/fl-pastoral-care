type ServiceLog @auth(rules: [{ isAuthenticated: true }]) {
  id: ID
  historyRecord: String #leader was transferred to
  created_at: TimeGraph @relationship(type: "RECORDED_ON", direction: OUT)
  loggedBy: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceRecords: [ServiceRecord!]!
    @relationship(type: "HAS_SERVICE", direction: OUT)
  leaders: [Member!]! @relationship(type: "HAS_HISTORY", direction: IN)
  fellowship: [Fellowship!]! @relationship(type: "HAS_HISTORY", direction: IN)
  bacenta: [Bacenta!]! @relationship(type: "HAS_HISTORY", direction: IN)
  # bacentaFellowshipRecords(bacentaId: ID!): [BacentaFellowshipServiceRecords!]!
  constituency: [Constituency!]!
    @relationship(type: "HAS_HISTORY", direction: IN)
  council: [Council!]! @relationship(type: "HAS_HISTORY", direction: IN)
  sonta: [Sonta!]! @relationship(type: "HAS_HISTORY", direction: IN)
}

type ServiceDay @auth(rules: [{ isAuthenticated: true }]) {
  day: String!
  dayNumber: Int
  fellowship: Fellowship @relationship(type: "MEETS_ON", direction: IN)
}

interface Record {
  id: ID!
  created_at: DateTime!
  created_by: Member! @relationship(type: "LOGGED_BY", direction: OUT)
  membersAttended: [Member!]!
    @relationship(type: "ATTENDED_SERVICE", direction: IN)
  membersAbsent: [Member!]!
    @relationship(type: "ABSENT_FROM_SERVICE", direction: IN)
}

type ServiceRecord implements Record @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  created_at: DateTime!
  created_by: Member!
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  attendance: Int
  income: Float
  foreignCurrency: String
  servicePicture: String
  treasurerSelfie: String
  bankingSlip: String
  treasurers: [Member!]! @relationship(type: "WAS_TREASURER_FOR", direction: IN)
  serviceLog: ServiceLog @relationship(type: "HAS_SERVICE", direction: IN)
  membersAttended: [Member!]!
    @relationship(type: "ATTENDED_SERVICE", direction: IN)
  membersAbsent: [Member!]!
    @relationship(type: "ABSENT_FROM_SERVICE", direction: IN)
  noServiceReason: String
}

type BussingRecord implements Record @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!

  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:BUSSED_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  # Mobilisation
  created_at: DateTime! #mobilisation time is the time the record was created
  serviceDate: TimeGraph! @relationship(type: "BUSSED_ON", direction: OUT)
  mobilisationPicture: String!
  created_by: Member! @relationship(type: "LOGGED_BY", direction: OUT)

  #On The Way
  bussingPictures: [String]
  attendance: Int
  leaderDeclaration: Int
  numberOfBusses: Int
  numberOfCars: Int
  bussingCost: Float
  bussingTopUp: Float
  counted_by: Member @relationship(type: "COUNTED_BY", direction: OUT)

  #Arrived
  comments: String
  arrivalTime: DateTime
  transactionId: Int
  arrival_confirmed_by: Member
    @relationship(type: "ARRIVAL_CONFIRMED_BY", direction: OUT)

  serviceLog: ServiceLog @relationship(type: "HAS_BUSSING", direction: IN)
  membersAttended: [Member!]!
    @relationship(type: "ATTENDED_SERVICE", direction: IN)
  membersAbsent: [Member!]!
    @relationship(type: "ABSENT_FROM_SERVICE", direction: IN)
}

extend type Member {
  attendedServices: [ServiceRecord!]!
    @relationship(type: "ATTENDED_SERVICE", direction: OUT)
}

type Mutation {
  RecordMemberFellowshipPresent(
    presentMembers: [ID!]!
    churchId: ID!
  ): ServiceRecord
    @cypher(
      statement: """
      MATCH (church:Fellowship {id: $churchId})
      MATCH (church)-[:CURRENT_HISTORY]->(history:ServiceLog)-[:HAS_SERVICE]->(service:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph {date: date()})

      UNWIND $presentMembers AS presentMemberId
      MATCH (present:Member {id: presentMemberId})
      MERGE (present)-[:ATTENDED_SERVICE]->(service)

      RETURN service
      """
    )
  RecordMemberFellowshipAbsent(
    absentMembers: [ID!]!
    churchId: ID!
  ): ServiceRecord
    @cypher(
      statement: """
      MATCH (church:Fellowship {id: $churchId})
      MATCH (church)-[:CURRENT_HISTORY]->(history:ServiceLog)-[:HAS_SERVICE]->(service:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph {date: date()})

      UNWIND $absentMembers AS absentMemberId
      MATCH (absent:Member {id: absentMemberId})
      MERGE (absent)-[:ABSENT_FROM_SERVICE]->(service)

      RETURN service
      """
    )
  RecordMemberBacentaPresent(
    presentMembers: [ID!]!
    churchId: ID!
  ): BussingRecord
    @cypher(
      statement: """
      MATCH (church:Bacenta {id: $churchId})
      MATCH (church)-[:CURRENT_HISTORY]->(history:ServiceLog)-[:HAS_BUSSING]->(service:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph {date: date()})

      UNWIND $presentMembers AS presentMemberId
      MATCH (member:Member {id: presentMemberId})
      MERGE (member)-[:ATTENDED_SERVICE]->(service)

      RETURN service
      """
    )
  RecordMemberBacentaAbsent(
    absentMembers: [ID!]!
    churchId: ID!
  ): BussingRecord
    @cypher(
      statement: """
      MATCH (church:Bacenta {id: $churchId})
      MATCH (church)-[:CURRENT_HISTORY]->(history:ServiceLog)-[:HAS_BUSSING]->(service:BussingRecord)-[:BUSSED_ON]->(date:TimeGraph {date: date()})

      UNWIND $absentMembers AS absentMemberId
      MATCH (member:Member {id: absentMemberId})
      MERGE (member)-[:ABSENT_FROM_SERVICE]->(service)

      RETURN service
      """
    )
}
